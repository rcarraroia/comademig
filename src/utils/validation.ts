import { z } from 'zod';\n\n// Schemas de validação centralizados\n\n// Schema para tipos de membro\nexport const memberTypeSchema = z.object({\n  name: z.string()\n    .min(2, 'Nome deve ter pelo menos 2 caracteres')\n    .max(100, 'Nome deve ter no máximo 100 caracteres')\n    .regex(/^[a-zA-ZÀ-ÿ\\s]+$/, 'Nome deve conter apenas letras e espaços'),\n  \n  description: z.string()\n    .max(500, 'Descrição deve ter no máximo 500 caracteres')\n    .optional(),\n  \n  is_active: z.boolean().default(true),\n  \n  sort_order: z.number()\n    .int('Ordem deve ser um número inteiro')\n    .min(0, 'Ordem deve ser maior ou igual a 0')\n    .max(999, 'Ordem deve ser menor que 1000')\n});\n\n// Schema para planos de assinatura\nexport const subscriptionPlanSchema = z.object({\n  name: z.string()\n    .min(3, 'Nome deve ter pelo menos 3 caracteres')\n    .max(100, 'Nome deve ter no máximo 100 caracteres'),\n  \n  description: z.string()\n    .max(1000, 'Descrição deve ter no máximo 1000 caracteres')\n    .optional(),\n  \n  price: z.number()\n    .positive('Preço deve ser maior que zero')\n    .max(9999.99, 'Preço deve ser menor que R$ 10.000,00')\n    .multipleOf(0.01, 'Preço deve ter no máximo 2 casas decimais'),\n  \n  recurrence: z.enum(['monthly', 'semestral', 'annual'], {\n    errorMap: () => ({ message: 'Recorrência deve ser mensal, semestral ou anual' })\n  }),\n  \n  permissions: z.object({\n    manage_events: z.boolean().default(false),\n    manage_news: z.boolean().default(false),\n    manage_media: z.boolean().default(false)\n  }).refine(\n    (permissions) => Object.values(permissions).some(Boolean),\n    'Pelo menos uma permissão deve ser selecionada'\n  ),\n  \n  member_types: z.array(z.string().uuid('ID do tipo de membro deve ser um UUID válido'))\n    .min(1, 'Pelo menos um tipo de membro deve ser selecionado'),\n  \n  is_active: z.boolean().default(true),\n  \n  sort_order: z.number()\n    .int('Ordem deve ser um número inteiro')\n    .min(0, 'Ordem deve ser maior ou igual a 0')\n    .max(999, 'Ordem deve ser menor que 1000')\n});\n\n// Schema para assinatura de usuário\nexport const userSubscriptionSchema = z.object({\n  user_id: z.string().uuid('ID do usuário deve ser um UUID válido'),\n  \n  subscription_plan_id: z.string().uuid('ID do plano deve ser um UUID válido'),\n  \n  member_type_id: z.string().uuid('ID do tipo de membro deve ser um UUID válido'),\n  \n  status: z.enum(['active', 'inactive', 'pending', 'cancelled'], {\n    errorMap: () => ({ message: 'Status deve ser ativo, inativo, pendente ou cancelado' })\n  }).default('pending'),\n  \n  payment_reference: z.string().optional(),\n  \n  start_date: z.string().datetime('Data de início deve ser uma data válida').optional(),\n  \n  end_date: z.string().datetime('Data de término deve ser uma data válida').optional()\n}).refine(\n  (data) => {\n    if (data.start_date && data.end_date) {\n      return new Date(data.start_date) < new Date(data.end_date);\n    }\n    return true;\n  },\n  {\n    message: 'Data de término deve ser posterior à data de início',\n    path: ['end_date']\n  }\n);\n\n// Schema para dados de perfil\nexport const profileSchema = z.object({\n  nome_completo: z.string()\n    .min(3, 'Nome completo deve ter pelo menos 3 caracteres')\n    .max(200, 'Nome completo deve ter no máximo 200 caracteres')\n    .regex(/^[a-zA-ZÀ-ÿ\\s]+$/, 'Nome deve conter apenas letras e espaços'),\n  \n  cpf: z.string()\n    .regex(/^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$|^\\d{11}$/, 'CPF deve estar no formato 000.000.000-00 ou conter 11 dígitos')\n    .optional()\n    .or(z.literal('')),\n  \n  rg: z.string()\n    .max(20, 'RG deve ter no máximo 20 caracteres')\n    .optional()\n    .or(z.literal('')),\n  \n  data_nascimento: z.string()\n    .regex(/^\\d{4}-\\d{2}-\\d{2}$/, 'Data deve estar no formato YYYY-MM-DD')\n    .refine(\n      (date) => {\n        const birthDate = new Date(date);\n        const today = new Date();\n        const age = today.getFullYear() - birthDate.getFullYear();\n        return age >= 16 && age <= 120;\n      },\n      'Idade deve estar entre 16 e 120 anos'\n    )\n    .optional()\n    .or(z.literal('')),\n  \n  telefone: z.string()\n    .regex(/^\\(\\d{2}\\)\\s\\d{4,5}-\\d{4}$|^\\d{10,11}$/, 'Telefone deve estar no formato (00) 00000-0000')\n    .optional()\n    .or(z.literal('')),\n  \n  endereco: z.string()\n    .max(300, 'Endereço deve ter no máximo 300 caracteres')\n    .optional()\n    .or(z.literal('')),\n  \n  cidade: z.string()\n    .max(100, 'Cidade deve ter no máximo 100 caracteres')\n    .optional()\n    .or(z.literal('')),\n  \n  estado: z.string()\n    .length(2, 'Estado deve ter 2 caracteres (ex: MG)')\n    .regex(/^[A-Z]{2}$/, 'Estado deve conter apenas letras maiúsculas')\n    .optional()\n    .or(z.literal('')),\n  \n  cep: z.string()\n    .regex(/^\\d{5}-\\d{3}$|^\\d{8}$/, 'CEP deve estar no formato 00000-000 ou conter 8 dígitos')\n    .optional()\n    .or(z.literal('')),\n  \n  igreja: z.string()\n    .max(200, 'Nome da igreja deve ter no máximo 200 caracteres')\n    .optional()\n    .or(z.literal('')),\n  \n  cargo: z.string()\n    .max(100, 'Cargo deve ter no máximo 100 caracteres')\n    .optional()\n    .or(z.literal('')),\n  \n  data_ordenacao: z.string()\n    .regex(/^\\d{4}-\\d{2}-\\d{2}$/, 'Data deve estar no formato YYYY-MM-DD')\n    .refine(\n      (date) => {\n        const ordinationDate = new Date(date);\n        const today = new Date();\n        return ordinationDate <= today;\n      },\n      'Data de ordenação não pode ser futura'\n    )\n    .optional()\n    .or(z.literal('')),\n  \n  bio: z.string()\n    .max(1000, 'Biografia deve ter no máximo 1000 caracteres')\n    .optional()\n    .or(z.literal(''))\n});\n\n// Schema para dados de pagamento\nexport const paymentDataSchema = z.object({\n  customer: z.object({\n    name: z.string().min(3, 'Nome deve ter pelo menos 3 caracteres'),\n    email: z.string().email('Email deve ser válido'),\n    cpfCnpj: z.string().min(11, 'CPF/CNPJ deve ter pelo menos 11 caracteres'),\n    phone: z.string().optional(),\n    address: z.string().optional(),\n    addressNumber: z.string().optional(),\n    city: z.string().optional(),\n    province: z.string().default('MG'),\n    postalCode: z.string().optional()\n  }),\n  \n  billingType: z.enum(['BOLETO', 'CREDIT_CARD', 'PIX']),\n  \n  value: z.number().positive('Valor deve ser maior que zero'),\n  \n  dueDate: z.string().regex(/^\\d{4}-\\d{2}-\\d{2}$/, 'Data deve estar no formato YYYY-MM-DD'),\n  \n  description: z.string().min(5, 'Descrição deve ter pelo menos 5 caracteres'),\n  \n  tipoCobranca: z.string().optional(),\n  \n  referenciaId: z.string().optional(),\n  \n  affiliateId: z.string().optional()\n});\n\n// Schema para log de auditoria\nexport const auditLogSchema = z.object({\n  table_name: z.string().min(1, 'Nome da tabela é obrigatório'),\n  \n  operation: z.enum(['INSERT', 'UPDATE', 'DELETE', 'LOGIN', 'LOGOUT', 'VIEW', 'DOWNLOAD']),\n  \n  record_id: z.string().min(1, 'ID do registro é obrigatório'),\n  \n  old_values: z.record(z.any()).optional(),\n  \n  new_values: z.record(z.any()).optional(),\n  \n  description: z.string().max(500, 'Descrição deve ter no máximo 500 caracteres').optional(),\n  \n  metadata: z.record(z.any()).optional()\n});\n\n// Funções utilitárias de validação\n\n/**\n * Valida CPF\n */\nexport const validateCPF = (cpf: string): boolean => {\n  const cleanCPF = cpf.replace(/\\D/g, '');\n  \n  if (cleanCPF.length !== 11) return false;\n  if (/^(\\d)\\1{10}$/.test(cleanCPF)) return false; // CPFs com todos os dígitos iguais\n  \n  // Validação dos dígitos verificadores\n  let sum = 0;\n  for (let i = 0; i < 9; i++) {\n    sum += parseInt(cleanCPF.charAt(i)) * (10 - i);\n  }\n  \n  let remainder = (sum * 10) % 11;\n  if (remainder === 10 || remainder === 11) remainder = 0;\n  if (remainder !== parseInt(cleanCPF.charAt(9))) return false;\n  \n  sum = 0;\n  for (let i = 0; i < 10; i++) {\n    sum += parseInt(cleanCPF.charAt(i)) * (11 - i);\n  }\n  \n  remainder = (sum * 10) % 11;\n  if (remainder === 10 || remainder === 11) remainder = 0;\n  if (remainder !== parseInt(cleanCPF.charAt(10))) return false;\n  \n  return true;\n};\n\n/**\n * Valida CNPJ\n */\nexport const validateCNPJ = (cnpj: string): boolean => {\n  const cleanCNPJ = cnpj.replace(/\\D/g, '');\n  \n  if (cleanCNPJ.length !== 14) return false;\n  if (/^(\\d)\\1{13}$/.test(cleanCNPJ)) return false; // CNPJs com todos os dígitos iguais\n  \n  // Validação dos dígitos verificadores\n  const weights1 = [5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2];\n  const weights2 = [6, 7, 8, 9, 2, 3, 4, 5, 6, 7, 8, 9];\n  \n  let sum = 0;\n  for (let i = 0; i < 12; i++) {\n    sum += parseInt(cleanCNPJ.charAt(i)) * weights1[i];\n  }\n  \n  let remainder = sum % 11;\n  const digit1 = remainder < 2 ? 0 : 11 - remainder;\n  \n  if (digit1 !== parseInt(cleanCNPJ.charAt(12))) return false;\n  \n  sum = 0;\n  for (let i = 0; i < 13; i++) {\n    sum += parseInt(cleanCNPJ.charAt(i)) * weights2[i];\n  }\n  \n  remainder = sum % 11;\n  const digit2 = remainder < 2 ? 0 : 11 - remainder;\n  \n  if (digit2 !== parseInt(cleanCNPJ.charAt(13))) return false;\n  \n  return true;\n};\n\n/**\n * Valida email\n */\nexport const validateEmail = (email: string): boolean => {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n};\n\n/**\n * Valida telefone brasileiro\n */\nexport const validatePhone = (phone: string): boolean => {\n  const cleanPhone = phone.replace(/\\D/g, '');\n  return cleanPhone.length === 10 || cleanPhone.length === 11;\n};\n\n/**\n * Valida CEP brasileiro\n */\nexport const validateCEP = (cep: string): boolean => {\n  const cleanCEP = cep.replace(/\\D/g, '');\n  return cleanCEP.length === 8;\n};\n\n/**\n * Formata CPF\n */\nexport const formatCPF = (cpf: string): string => {\n  const cleanCPF = cpf.replace(/\\D/g, '');\n  return cleanCPF.replace(/(\\d{3})(\\d{3})(\\d{3})(\\d{2})/, '$1.$2.$3-$4');\n};\n\n/**\n * Formata CNPJ\n */\nexport const formatCNPJ = (cnpj: string): string => {\n  const cleanCNPJ = cnpj.replace(/\\D/g, '');\n  return cleanCNPJ.replace(/(\\d{2})(\\d{3})(\\d{3})(\\d{4})(\\d{2})/, '$1.$2.$3/$4-$5');\n};\n\n/**\n * Formata telefone\n */\nexport const formatPhone = (phone: string): string => {\n  const cleanPhone = phone.replace(/\\D/g, '');\n  \n  if (cleanPhone.length === 10) {\n    return cleanPhone.replace(/(\\d{2})(\\d{4})(\\d{4})/, '($1) $2-$3');\n  } else if (cleanPhone.length === 11) {\n    return cleanPhone.replace(/(\\d{2})(\\d{5})(\\d{4})/, '($1) $2-$3');\n  }\n  \n  return phone;\n};\n\n/**\n * Formata CEP\n */\nexport const formatCEP = (cep: string): string => {\n  const cleanCEP = cep.replace(/\\D/g, '');\n  return cleanCEP.replace(/(\\d{5})(\\d{3})/, '$1-$2');\n};\n\n/**\n * Sanitiza string removendo caracteres especiais\n */\nexport const sanitizeString = (str: string): string => {\n  return str.replace(/[<>\"'&]/g, '');\n};\n\n/**\n * Valida se uma data está no futuro\n */\nexport const isDateInFuture = (date: string): boolean => {\n  return new Date(date) > new Date();\n};\n\n/**\n * Valida se uma data está no passado\n */\nexport const isDateInPast = (date: string): boolean => {\n  return new Date(date) < new Date();\n};\n\n/**\n * Calcula idade a partir da data de nascimento\n */\nexport const calculateAge = (birthDate: string): number => {\n  const today = new Date();\n  const birth = new Date(birthDate);\n  let age = today.getFullYear() - birth.getFullYear();\n  const monthDiff = today.getMonth() - birth.getMonth();\n  \n  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {\n    age--;\n  }\n  \n  return age;\n};\n\n// Exportar todos os schemas\nexport const schemas = {\n  memberType: memberTypeSchema,\n  subscriptionPlan: subscriptionPlanSchema,\n  userSubscription: userSubscriptionSchema,\n  profile: profileSchema,\n  paymentData: paymentDataSchema,\n  auditLog: auditLogSchema\n};\n\n// Função para validar dados com schema específico\nexport const validateWithSchema = <T>(schema: z.ZodSchema<T>, data: unknown): T => {\n  try {\n    return schema.parse(data);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      const errorMessages = error.errors.map(err => `${err.path.join('.')}: ${err.message}`);\n      throw new Error(`Erro de validação: ${errorMessages.join(', ')}`);\n    }\n    throw error;\n  }\n};\n\n// Função para validar dados e retornar apenas erros\nexport const getValidationErrors = <T>(schema: z.ZodSchema<T>, data: unknown): string[] => {\n  try {\n    schema.parse(data);\n    return [];\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return error.errors.map(err => `${err.path.join('.')}: ${err.message}`);\n    }\n    return ['Erro de validação desconhecido'];\n  }\n};"