import { renderHook, waitFor } from '@testing-library/react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { ReactNode } from 'react';\nimport { useMemberTypes } from '@/hooks/useMemberTypes';\nimport { supabase } from '@/integrations/supabase/client';\n\n// Mock do Supabase\njest.mock('@/integrations/supabase/client', () => ({\n  supabase: {\n    from: jest.fn(() => ({\n      select: jest.fn(() => ({\n        eq: jest.fn(() => ({\n          order: jest.fn(() => ({\n            then: jest.fn()\n          }))\n        }))\n      })),\n      insert: jest.fn(() => ({\n        select: jest.fn(() => ({\n          single: jest.fn()\n        }))\n      })),\n      update: jest.fn(() => ({\n        eq: jest.fn(() => ({\n          select: jest.fn(() => ({\n            single: jest.fn()\n          }))\n        }))\n      })),\n      delete: jest.fn(() => ({\n        eq: jest.fn()\n      }))\n    }))\n  }\n}));\n\n// Mock dos dados de teste\nconst mockMemberTypes = [\n  {\n    id: '1',\n    name: 'Pastor',\n    description: 'Pastor da igreja local',\n    is_active: true,\n    sort_order: 1,\n    created_at: '2024-01-01T00:00:00Z',\n    updated_at: '2024-01-01T00:00:00Z'\n  },\n  {\n    id: '2',\n    name: 'Evangelista',\n    description: 'Evangelista itinerante',\n    is_active: true,\n    sort_order: 2,\n    created_at: '2024-01-01T00:00:00Z',\n    updated_at: '2024-01-01T00:00:00Z'\n  }\n];\n\n// Wrapper para React Query\nconst createWrapper = () => {\n  const queryClient = new QueryClient({\n    defaultOptions: {\n      queries: {\n        retry: false,\n      },\n    },\n  });\n  \n  return ({ children }: { children: ReactNode }) => (\n    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\n  );\n};\n\ndescribe('useMemberTypes', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('Buscar tipos de membro', () => {\n    it('deve buscar tipos de membro com sucesso', async () => {\n      // Mock da resposta do Supabase\n      const mockSupabaseChain = {\n        eq: jest.fn().mockReturnThis(),\n        order: jest.fn().mockResolvedValue({\n          data: mockMemberTypes,\n          error: null\n        })\n      };\n      \n      const mockSelect = jest.fn().mockReturnValue(mockSupabaseChain);\n      const mockFrom = jest.fn().mockReturnValue({ select: mockSelect });\n      \n      (supabase.from as jest.Mock).mockReturnValue({ select: mockSelect });\n      \n      const { result } = renderHook(() => useMemberTypes(), {\n        wrapper: createWrapper()\n      });\n\n      await waitFor(() => {\n        expect(result.current.isLoading).toBe(false);\n      });\n\n      expect(result.current.memberTypes).toEqual(mockMemberTypes);\n      expect(result.current.error).toBeNull();\n    });\n\n    it('deve lidar com erro ao buscar tipos de membro', async () => {\n      const mockError = new Error('Erro de conexão');\n      \n      const mockSupabaseChain = {\n        eq: jest.fn().mockReturnThis(),\n        order: jest.fn().mockResolvedValue({\n          data: null,\n          error: mockError\n        })\n      };\n      \n      const mockSelect = jest.fn().mockReturnValue(mockSupabaseChain);\n      (supabase.from as jest.Mock).mockReturnValue({ select: mockSelect });\n\n      const { result } = renderHook(() => useMemberTypes(), {\n        wrapper: createWrapper()\n      });\n\n      await waitFor(() => {\n        expect(result.current.isLoading).toBe(false);\n      });\n\n      expect(result.current.memberTypes).toEqual([]);\n      expect(result.current.error).toBeTruthy();\n    });\n  });\n\n  describe('Criar tipo de membro', () => {\n    it('deve criar tipo de membro com sucesso', async () => {\n      const newMemberType = {\n        name: 'Diácono',\n        description: 'Diácono da igreja',\n        is_active: true,\n        sort_order: 3\n      };\n\n      const createdMemberType = {\n        id: '3',\n        ...newMemberType,\n        created_at: '2024-01-01T00:00:00Z',\n        updated_at: '2024-01-01T00:00:00Z'\n      };\n\n      const mockSupabaseChain = {\n        select: jest.fn(() => ({\n          single: jest.fn().mockResolvedValue({\n            data: createdMemberType,\n            error: null\n          })\n        }))\n      };\n      \n      const mockInsert = jest.fn().mockReturnValue(mockSupabaseChain);\n      (supabase.from as jest.Mock).mockReturnValue({ insert: mockInsert });\n\n      const { result } = renderHook(() => useMemberTypes(), {\n        wrapper: createWrapper()\n      });\n\n      await waitFor(() => {\n        expect(result.current.isLoading).toBe(false);\n      });\n\n      // Testar a mutation\n      result.current.createMemberType.mutate(newMemberType);\n\n      await waitFor(() => {\n        expect(result.current.createMemberType.isSuccess).toBe(true);\n      });\n\n      expect(mockInsert).toHaveBeenCalledWith(newMemberType);\n    });\n  });\n\n  describe('Validação de dados', () => {\n    it('deve validar dados obrigatórios', () => {\n      const { result } = renderHook(() => useMemberTypes(), {\n        wrapper: createWrapper()\n      });\n\n      const invalidData = {\n        name: '', // Nome vazio\n        description: 'Descrição válida',\n        is_active: true,\n        sort_order: 1\n      };\n\n      expect(() => {\n        result.current.validateMemberType(invalidData);\n      }).toThrow();\n    });\n\n    it('deve aceitar dados válidos', () => {\n      const { result } = renderHook(() => useMemberTypes(), {\n        wrapper: createWrapper()\n      });\n\n      const validData = {\n        name: 'Pastor Auxiliar',\n        description: 'Pastor auxiliar da igreja',\n        is_active: true,\n        sort_order: 4\n      };\n\n      expect(() => {\n        result.current.validateMemberType(validData);\n      }).not.toThrow();\n    });\n  });\n\n  describe('Utilitários', () => {\n    it('deve filtrar tipos ativos corretamente', () => {\n      const { result } = renderHook(() => useMemberTypes(), {\n        wrapper: createWrapper()\n      });\n\n      const mixedTypes = [\n        { ...mockMemberTypes[0], is_active: true },\n        { ...mockMemberTypes[1], is_active: false }\n      ];\n\n      const activeTypes = result.current.getActiveTypes(mixedTypes);\n      \n      expect(activeTypes).toHaveLength(1);\n      expect(activeTypes[0].is_active).toBe(true);\n    });\n\n    it('deve ordenar tipos por sort_order', () => {\n      const { result } = renderHook(() => useMemberTypes(), {\n        wrapper: createWrapper()\n      });\n\n      const unorderedTypes = [\n        { ...mockMemberTypes[0], sort_order: 3 },\n        { ...mockMemberTypes[1], sort_order: 1 }\n      ];\n\n      const orderedTypes = result.current.sortByOrder(unorderedTypes);\n      \n      expect(orderedTypes[0].sort_order).toBe(1);\n      expect(orderedTypes[1].sort_order).toBe(3);\n    });\n  });\n});"