import { useCallback, useMemo } from 'react';\nimport { useQueryClient } from '@tanstack/react-query';\nimport { supabase } from '@/integrations/supabase/client';\n\n// Interface para métricas de performance\nexport interface PerformanceMetrics {\n  queryTime: number;\n  cacheHits: number;\n  cacheMisses: number;\n  totalQueries: number;\n  averageQueryTime: number;\n}\n\n// Interface para configuração de cache\nexport interface CacheConfig {\n  staleTime: number;\n  cacheTime: number;\n  refetchOnWindowFocus: boolean;\n  refetchOnMount: boolean;\n}\n\nexport const usePerformanceOptimization = () => {\n  const queryClient = useQueryClient();\n\n  // Configurações otimizadas de cache por tipo de dados\n  const cacheConfigs = useMemo(() => ({\n    // Dados que mudam raramente - cache longo\n    static: {\n      staleTime: 30 * 60 * 1000, // 30 minutos\n      cacheTime: 60 * 60 * 1000, // 1 hora\n      refetchOnWindowFocus: false,\n      refetchOnMount: false\n    } as CacheConfig,\n    \n    // Dados que mudam ocasionalmente - cache médio\n    semiStatic: {\n      staleTime: 10 * 60 * 1000, // 10 minutos\n      cacheTime: 30 * 60 * 1000, // 30 minutos\n      refetchOnWindowFocus: false,\n      refetchOnMount: true\n    } as CacheConfig,\n    \n    // Dados que mudam frequentemente - cache curto\n    dynamic: {\n      staleTime: 2 * 60 * 1000, // 2 minutos\n      cacheTime: 10 * 60 * 1000, // 10 minutos\n      refetchOnWindowFocus: true,\n      refetchOnMount: true\n    } as CacheConfig,\n    \n    // Dados em tempo real - sem cache\n    realtime: {\n      staleTime: 0,\n      cacheTime: 0,\n      refetchOnWindowFocus: true,\n      refetchOnMount: true\n    } as CacheConfig\n  }), []);\n\n  // Função para obter configuração de cache otimizada\n  const getCacheConfig = useCallback((dataType: keyof typeof cacheConfigs): CacheConfig => {\n    return cacheConfigs[dataType];\n  }, [cacheConfigs]);\n\n  // Função para pré-carregar dados críticos\n  const prefetchCriticalData = useCallback(async (userId: string) => {\n    const prefetchPromises = [\n      // Pré-carregar perfil do usuário\n      queryClient.prefetchQuery({\n        queryKey: ['profile', userId],\n        queryFn: async () => {\n          const { data } = await supabase\n            .from('profiles')\n            .select('*')\n            .eq('id', userId)\n            .single();\n          return data;\n        },\n        ...getCacheConfig('semiStatic')\n      }),\n      \n      // Pré-carregar tipos de membro\n      queryClient.prefetchQuery({\n        queryKey: ['member-types'],\n        queryFn: async () => {\n          const { data } = await supabase\n            .from('member_types')\n            .select('*')\n            .eq('is_active', true)\n            .order('sort_order');\n          return data;\n        },\n        ...getCacheConfig('static')\n      }),\n      \n      // Pré-carregar assinatura ativa\n      queryClient.prefetchQuery({\n        queryKey: ['active-subscription', userId],\n        queryFn: async () => {\n          const { data } = await supabase\n            .from('user_subscriptions')\n            .select(`\n              *,\n              subscription_plans(*),\n              member_types(*)\n            `)\n            .eq('user_id', userId)\n            .eq('status', 'active')\n            .single();\n          return data;\n        },\n        ...getCacheConfig('semiStatic')\n      })\n    ];\n\n    try {\n      await Promise.all(prefetchPromises);\n      console.log('Dados críticos pré-carregados com sucesso');\n    } catch (error) {\n      console.error('Erro ao pré-carregar dados:', error);\n    }\n  }, [queryClient, getCacheConfig]);\n\n  // Função para invalidar cache seletivamente\n  const invalidateRelatedCache = useCallback((operation: string, tableName: string, recordId?: string) => {\n    const invalidationMap: Record<string, string[]> = {\n      'member_types': [\n        'member-types',\n        'subscription-plans',\n        'member-type-subscriptions'\n      ],\n      'subscription_plans': [\n        'subscription-plans',\n        'member-type-subscriptions',\n        'user-subscriptions'\n      ],\n      'user_subscriptions': [\n        'user-subscriptions',\n        'active-subscription',\n        'user-permissions'\n      ],\n      'profiles': [\n        'profile',\n        'user-profile'\n      ]\n    };\n\n    const keysToInvalidate = invalidationMap[tableName] || [tableName];\n    \n    keysToInvalidate.forEach(key => {\n      if (recordId) {\n        queryClient.invalidateQueries({ queryKey: [key, recordId] });\n      } else {\n        queryClient.invalidateQueries({ queryKey: [key] });\n      }\n    });\n\n    console.log(`Cache invalidado para operação ${operation} na tabela ${tableName}`);\n  }, [queryClient]);\n\n  // Função para otimizar queries com índices\n  const optimizeQuery = useCallback((baseQuery: any, filters: Record<string, any>) => {\n    let optimizedQuery = baseQuery;\n\n    // Aplicar filtros na ordem mais eficiente (índices primeiro)\n    const indexedFields = ['id', 'user_id', 'status', 'is_active', 'created_at'];\n    const nonIndexedFields = Object.keys(filters).filter(key => !indexedFields.includes(key));\n    \n    // Aplicar filtros indexados primeiro\n    indexedFields.forEach(field => {\n      if (filters[field] !== undefined) {\n        if (Array.isArray(filters[field])) {\n          optimizedQuery = optimizedQuery.in(field, filters[field]);\n        } else {\n          optimizedQuery = optimizedQuery.eq(field, filters[field]);\n        }\n      }\n    });\n    \n    // Aplicar filtros não-indexados depois\n    nonIndexedFields.forEach(field => {\n      if (filters[field] !== undefined) {\n        if (typeof filters[field] === 'string' && filters[field].includes('%')) {\n          optimizedQuery = optimizedQuery.like(field, filters[field]);\n        } else if (Array.isArray(filters[field])) {\n          optimizedQuery = optimizedQuery.in(field, filters[field]);\n        } else {\n          optimizedQuery = optimizedQuery.eq(field, filters[field]);\n        }\n      }\n    });\n\n    return optimizedQuery;\n  }, []);\n\n  // Função para monitorar performance de queries\n  const measureQueryPerformance = useCallback(async <T>(\n    queryName: string,\n    queryFn: () => Promise<T>\n  ): Promise<T> => {\n    const startTime = performance.now();\n    \n    try {\n      const result = await queryFn();\n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      \n      // Log performance apenas em desenvolvimento\n      if (process.env.NODE_ENV === 'development') {\n        console.log(`Query ${queryName} executada em ${duration.toFixed(2)}ms`);\n        \n        // Alertar sobre queries lentas\n        if (duration > 1000) {\n          console.warn(`⚠️ Query lenta detectada: ${queryName} (${duration.toFixed(2)}ms)`);\n        }\n      }\n      \n      return result;\n    } catch (error) {\n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      \n      console.error(`Erro na query ${queryName} após ${duration.toFixed(2)}ms:`, error);\n      throw error;\n    }\n  }, []);\n\n  // Função para limpar cache antigo\n  const cleanupOldCache = useCallback(() => {\n    const now = Date.now();\n    const maxAge = 24 * 60 * 60 * 1000; // 24 horas\n    \n    queryClient.getQueryCache().getAll().forEach(query => {\n      const queryAge = now - (query.state.dataUpdatedAt || 0);\n      \n      if (queryAge > maxAge) {\n        queryClient.removeQueries({ queryKey: query.queryKey });\n      }\n    });\n    \n    console.log('Cache antigo limpo');\n  }, [queryClient]);\n\n  // Função para obter métricas de performance\n  const getPerformanceMetrics = useCallback((): PerformanceMetrics => {\n    const queries = queryClient.getQueryCache().getAll();\n    \n    const metrics = queries.reduce((acc, query) => {\n      const state = query.state;\n      \n      acc.totalQueries++;\n      \n      if (state.status === 'success' && state.dataUpdatedAt) {\n        acc.cacheHits++;\n      } else if (state.status === 'loading') {\n        acc.cacheMisses++;\n      }\n      \n      return acc;\n    }, {\n      queryTime: 0,\n      cacheHits: 0,\n      cacheMisses: 0,\n      totalQueries: 0,\n      averageQueryTime: 0\n    });\n    \n    metrics.averageQueryTime = metrics.totalQueries > 0 \n      ? metrics.queryTime / metrics.totalQueries \n      : 0;\n    \n    return metrics;\n  }, [queryClient]);\n\n  // Função para configurar otimizações automáticas\n  const setupAutoOptimizations = useCallback(() => {\n    // Limpar cache antigo a cada hora\n    const cleanupInterval = setInterval(cleanupOldCache, 60 * 60 * 1000);\n    \n    // Configurar garbage collection do React Query\n    queryClient.setDefaultOptions({\n      queries: {\n        gcTime: 30 * 60 * 1000, // 30 minutos\n        staleTime: 5 * 60 * 1000, // 5 minutos padrão\n        retry: (failureCount, error: any) => {\n          // Não tentar novamente para erros 4xx\n          if (error?.status >= 400 && error?.status < 500) {\n            return false;\n          }\n          return failureCount < 3;\n        },\n        retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000)\n      },\n      mutations: {\n        retry: 1,\n        retryDelay: 1000\n      }\n    });\n    \n    return () => {\n      clearInterval(cleanupInterval);\n    };\n  }, [queryClient, cleanupOldCache]);\n\n  return {\n    // Configurações\n    getCacheConfig,\n    cacheConfigs,\n    \n    // Otimizações\n    prefetchCriticalData,\n    invalidateRelatedCache,\n    optimizeQuery,\n    measureQueryPerformance,\n    \n    // Manutenção\n    cleanupOldCache,\n    setupAutoOptimizations,\n    \n    // Métricas\n    getPerformanceMetrics\n  };\n};"