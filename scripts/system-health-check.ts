#!/usr/bin/env tsx\n\n/**\n * Script de Verifica√ß√£o de Sa√∫de do Sistema\n * \n * Este script verifica se todos os componentes do sistema est√£o funcionando corretamente:\n * - Conectividade com banco de dados\n * - Estrutura das tabelas\n * - √çndices de performance\n * - Dados iniciais\n * - Permiss√µes RLS\n * - Funcionalidades cr√≠ticas\n */\n\nimport { createClient } from '@supabase/supabase-js';\nimport { config } from 'dotenv';\n\n// Carregar vari√°veis de ambiente\nconfig();\n\nconst supabaseUrl = process.env.VITE_SUPABASE_URL!;\nconst supabaseKey = process.env.VITE_SUPABASE_ANON_KEY!;\n\nif (!supabaseUrl || !supabaseKey) {\n  console.error('‚ùå Vari√°veis de ambiente do Supabase n√£o configuradas');\n  process.exit(1);\n}\n\nconst supabase = createClient(supabaseUrl, supabaseKey);\n\n// Cores para output\nconst colors = {\n  green: '\\x1b[32m',\n  red: '\\x1b[31m',\n  yellow: '\\x1b[33m',\n  blue: '\\x1b[34m',\n  reset: '\\x1b[0m',\n  bold: '\\x1b[1m'\n};\n\nconst log = {\n  success: (msg: string) => console.log(`${colors.green}‚úÖ ${msg}${colors.reset}`),\n  error: (msg: string) => console.log(`${colors.red}‚ùå ${msg}${colors.reset}`),\n  warning: (msg: string) => console.log(`${colors.yellow}‚ö†Ô∏è  ${msg}${colors.reset}`),\n  info: (msg: string) => console.log(`${colors.blue}‚ÑπÔ∏è  ${msg}${colors.reset}`),\n  title: (msg: string) => console.log(`\\n${colors.bold}${colors.blue}üîç ${msg}${colors.reset}\\n`)\n};\n\ninterface HealthCheckResult {\n  category: string;\n  checks: Array<{\n    name: string;\n    status: 'pass' | 'fail' | 'warning';\n    message: string;\n    details?: any;\n  }>;\n}\n\nclass SystemHealthChecker {\n  private results: HealthCheckResult[] = [];\n\n  async runAllChecks(): Promise<void> {\n    log.title('Iniciando Verifica√ß√£o de Sa√∫de do Sistema COMADEMIG');\n\n    await this.checkDatabaseConnection();\n    await this.checkTableStructure();\n    await this.checkIndexes();\n    await this.checkInitialData();\n    await this.checkRLSPolicies();\n    await this.checkCriticalFunctions();\n    await this.checkPerformance();\n\n    this.generateReport();\n  }\n\n  private async checkDatabaseConnection(): Promise<void> {\n    log.title('Verificando Conectividade com Banco de Dados');\n    \n    const result: HealthCheckResult = {\n      category: 'Database Connection',\n      checks: []\n    };\n\n    try {\n      const { data, error } = await supabase.from('profiles').select('count').limit(1);\n      \n      if (error) {\n        result.checks.push({\n          name: 'Conex√£o com Supabase',\n          status: 'fail',\n          message: `Erro de conex√£o: ${error.message}`,\n          details: error\n        });\n        log.error(`Falha na conex√£o: ${error.message}`);\n      } else {\n        result.checks.push({\n          name: 'Conex√£o com Supabase',\n          status: 'pass',\n          message: 'Conex√£o estabelecida com sucesso'\n        });\n        log.success('Conex√£o com Supabase estabelecida');\n      }\n    } catch (error) {\n      result.checks.push({\n        name: 'Conex√£o com Supabase',\n        status: 'fail',\n        message: `Erro inesperado: ${error}`,\n        details: error\n      });\n      log.error(`Erro inesperado na conex√£o: ${error}`);\n    }\n\n    this.results.push(result);\n  }\n\n  private async checkTableStructure(): Promise<void> {\n    log.title('Verificando Estrutura das Tabelas');\n    \n    const result: HealthCheckResult = {\n      category: 'Table Structure',\n      checks: []\n    };\n\n    const requiredTables = [\n      'member_types',\n      'subscription_plans',\n      'member_type_subscriptions',\n      'user_subscriptions',\n      'member_system_audit'\n    ];\n\n    for (const table of requiredTables) {\n      try {\n        const { data, error } = await supabase.from(table).select('*').limit(1);\n        \n        if (error) {\n          result.checks.push({\n            name: `Tabela ${table}`,\n            status: 'fail',\n            message: `Tabela n√£o encontrada ou inacess√≠vel: ${error.message}`,\n            details: error\n          });\n          log.error(`Tabela ${table}: ${error.message}`);\n        } else {\n          result.checks.push({\n            name: `Tabela ${table}`,\n            status: 'pass',\n            message: 'Tabela acess√≠vel'\n          });\n          log.success(`Tabela ${table} verificada`);\n        }\n      } catch (error) {\n        result.checks.push({\n          name: `Tabela ${table}`,\n          status: 'fail',\n          message: `Erro ao verificar tabela: ${error}`,\n          details: error\n        });\n        log.error(`Erro na tabela ${table}: ${error}`);\n      }\n    }\n\n    this.results.push(result);\n  }\n\n  private async checkIndexes(): Promise<void> {\n    log.title('Verificando √çndices de Performance');\n    \n    const result: HealthCheckResult = {\n      category: 'Performance Indexes',\n      checks: []\n    };\n\n    // Verificar se existem √≠ndices cr√≠ticos\n    const criticalIndexes = [\n      { table: 'member_types', column: 'is_active' },\n      { table: 'subscription_plans', column: 'is_active' },\n      { table: 'user_subscriptions', column: 'user_id' },\n      { table: 'user_subscriptions', column: 'status' },\n      { table: 'member_system_audit', column: 'created_at' }\n    ];\n\n    // Simular verifica√ß√£o de √≠ndices (em produ√ß√£o, usaria query espec√≠fica do PostgreSQL)\n    for (const index of criticalIndexes) {\n      try {\n        // Teste de performance simples\n        const start = Date.now();\n        const { data, error } = await supabase\n          .from(index.table)\n          .select('id')\n          .limit(100);\n        const duration = Date.now() - start;\n\n        if (error) {\n          result.checks.push({\n            name: `√çndice ${index.table}.${index.column}`,\n            status: 'fail',\n            message: `Erro ao testar √≠ndice: ${error.message}`,\n            details: { error, duration }\n          });\n          log.error(`√çndice ${index.table}.${index.column}: ${error.message}`);\n        } else if (duration > 1000) {\n          result.checks.push({\n            name: `√çndice ${index.table}.${index.column}`,\n            status: 'warning',\n            message: `Query lenta detectada: ${duration}ms`,\n            details: { duration, recordCount: data?.length }\n          });\n          log.warning(`√çndice ${index.table}.${index.column}: Query lenta (${duration}ms)`);\n        } else {\n          result.checks.push({\n            name: `√çndice ${index.table}.${index.column}`,\n            status: 'pass',\n            message: `Performance adequada: ${duration}ms`,\n            details: { duration, recordCount: data?.length }\n          });\n          log.success(`√çndice ${index.table}.${index.column}: ${duration}ms`);\n        }\n      } catch (error) {\n        result.checks.push({\n          name: `√çndice ${index.table}.${index.column}`,\n          status: 'fail',\n          message: `Erro inesperado: ${error}`,\n          details: error\n        });\n        log.error(`Erro no √≠ndice ${index.table}.${index.column}: ${error}`);\n      }\n    }\n\n    this.results.push(result);\n  }\n\n  private async checkInitialData(): Promise<void> {\n    log.title('Verificando Dados Iniciais');\n    \n    const result: HealthCheckResult = {\n      category: 'Initial Data',\n      checks: []\n    };\n\n    // Verificar tipos de membro padr√£o\n    try {\n      const { data: memberTypes, error } = await supabase\n        .from('member_types')\n        .select('*')\n        .eq('is_active', true);\n\n      if (error) {\n        result.checks.push({\n          name: 'Tipos de Membro Padr√£o',\n          status: 'fail',\n          message: `Erro ao buscar tipos: ${error.message}`,\n          details: error\n        });\n        log.error(`Tipos de membro: ${error.message}`);\n      } else if (!memberTypes || memberTypes.length === 0) {\n        result.checks.push({\n          name: 'Tipos de Membro Padr√£o',\n          status: 'warning',\n          message: 'Nenhum tipo de membro ativo encontrado',\n          details: { count: 0 }\n        });\n        log.warning('Nenhum tipo de membro ativo encontrado');\n      } else {\n        result.checks.push({\n          name: 'Tipos de Membro Padr√£o',\n          status: 'pass',\n          message: `${memberTypes.length} tipos ativos encontrados`,\n          details: { count: memberTypes.length, types: memberTypes.map(t => t.name) }\n        });\n        log.success(`${memberTypes.length} tipos de membro ativos`);\n      }\n    } catch (error) {\n      result.checks.push({\n        name: 'Tipos de Membro Padr√£o',\n        status: 'fail',\n        message: `Erro inesperado: ${error}`,\n        details: error\n      });\n      log.error(`Erro nos tipos de membro: ${error}`);\n    }\n\n    // Verificar planos de assinatura\n    try {\n      const { data: plans, error } = await supabase\n        .from('subscription_plans')\n        .select('*')\n        .eq('is_active', true);\n\n      if (error) {\n        result.checks.push({\n          name: 'Planos de Assinatura',\n          status: 'fail',\n          message: `Erro ao buscar planos: ${error.message}`,\n          details: error\n        });\n        log.error(`Planos de assinatura: ${error.message}`);\n      } else {\n        result.checks.push({\n          name: 'Planos de Assinatura',\n          status: plans && plans.length > 0 ? 'pass' : 'warning',\n          message: `${plans?.length || 0} planos ativos encontrados`,\n          details: { count: plans?.length || 0, plans: plans?.map(p => p.name) }\n        });\n        \n        if (plans && plans.length > 0) {\n          log.success(`${plans.length} planos de assinatura ativos`);\n        } else {\n          log.warning('Nenhum plano de assinatura ativo encontrado');\n        }\n      }\n    } catch (error) {\n      result.checks.push({\n        name: 'Planos de Assinatura',\n        status: 'fail',\n        message: `Erro inesperado: ${error}`,\n        details: error\n      });\n      log.error(`Erro nos planos de assinatura: ${error}`);\n    }\n\n    this.results.push(result);\n  }\n\n  private async checkRLSPolicies(): Promise<void> {\n    log.title('Verificando Pol√≠ticas RLS');\n    \n    const result: HealthCheckResult = {\n      category: 'RLS Policies',\n      checks: []\n    };\n\n    // Teste b√°sico de RLS - tentar acessar dados sem autentica√ß√£o\n    const tables = ['member_types', 'subscription_plans', 'user_subscriptions'];\n\n    for (const table of tables) {\n      try {\n        const { data, error } = await supabase.from(table).select('id').limit(1);\n        \n        // Para tabelas p√∫blicas (member_types, subscription_plans), deve funcionar\n        // Para tabelas privadas (user_subscriptions), deve falhar sem auth\n        \n        if (table === 'user_subscriptions') {\n          if (error && error.message.includes('RLS')) {\n            result.checks.push({\n              name: `RLS ${table}`,\n              status: 'pass',\n              message: 'RLS funcionando corretamente (acesso negado)',\n              details: { error: error.message }\n            });\n            log.success(`RLS ${table}: Acesso corretamente restrito`);\n          } else {\n            result.checks.push({\n              name: `RLS ${table}`,\n              status: 'warning',\n              message: 'RLS pode n√£o estar configurado corretamente',\n              details: { hasData: !!data, error: error?.message }\n            });\n            log.warning(`RLS ${table}: Poss√≠vel configura√ß√£o incorreta`);\n          }\n        } else {\n          if (data !== null) {\n            result.checks.push({\n              name: `RLS ${table}`,\n              status: 'pass',\n              message: 'Acesso p√∫blico funcionando',\n              details: { accessible: true }\n            });\n            log.success(`RLS ${table}: Acesso p√∫blico OK`);\n          } else if (error) {\n            result.checks.push({\n              name: `RLS ${table}`,\n              status: 'fail',\n              message: `Erro de acesso: ${error.message}`,\n              details: error\n            });\n            log.error(`RLS ${table}: ${error.message}`);\n          }\n        }\n      } catch (error) {\n        result.checks.push({\n          name: `RLS ${table}`,\n          status: 'fail',\n          message: `Erro inesperado: ${error}`,\n          details: error\n        });\n        log.error(`Erro RLS ${table}: ${error}`);\n      }\n    }\n\n    this.results.push(result);\n  }\n\n  private async checkCriticalFunctions(): Promise<void> {\n    log.title('Verificando Funcionalidades Cr√≠ticas');\n    \n    const result: HealthCheckResult = {\n      category: 'Critical Functions',\n      checks: []\n    };\n\n    // Teste de cria√ß√£o de tipo de membro (simulado)\n    try {\n      const testData = {\n        name: 'Teste Health Check',\n        description: 'Tipo criado para teste de sa√∫de do sistema',\n        is_active: false, // Inativo para n√£o interferir\n        sort_order: 999\n      };\n\n      // Tentar inserir (pode falhar por RLS, mas n√£o deve dar erro de estrutura)\n      const { data, error } = await supabase\n        .from('member_types')\n        .insert(testData)\n        .select()\n        .single();\n\n      if (error) {\n        if (error.message.includes('RLS') || error.message.includes('permission')) {\n          result.checks.push({\n            name: 'CRUD Tipos de Membro',\n            status: 'pass',\n            message: 'Estrutura OK (RLS bloqueou inser√ß√£o como esperado)',\n            details: { error: error.message }\n          });\n          log.success('CRUD Tipos: Estrutura verificada (RLS ativo)');\n        } else {\n          result.checks.push({\n            name: 'CRUD Tipos de Membro',\n            status: 'fail',\n            message: `Erro de estrutura: ${error.message}`,\n            details: error\n          });\n          log.error(`CRUD Tipos: ${error.message}`);\n        }\n      } else {\n        // Se conseguiu inserir, tentar deletar para limpar\n        if (data?.id) {\n          await supabase.from('member_types').delete().eq('id', data.id);\n        }\n        \n        result.checks.push({\n          name: 'CRUD Tipos de Membro',\n          status: 'pass',\n          message: 'Opera√ß√µes CRUD funcionando',\n          details: { inserted: true, cleaned: true }\n        });\n        log.success('CRUD Tipos: Funcionando corretamente');\n      }\n    } catch (error) {\n      result.checks.push({\n        name: 'CRUD Tipos de Membro',\n        status: 'fail',\n        message: `Erro inesperado: ${error}`,\n        details: error\n      });\n      log.error(`Erro CRUD Tipos: ${error}`);\n    }\n\n    this.results.push(result);\n  }\n\n  private async checkPerformance(): Promise<void> {\n    log.title('Verificando Performance Geral');\n    \n    const result: HealthCheckResult = {\n      category: 'Performance',\n      checks: []\n    };\n\n    // Teste de performance de queries comuns\n    const performanceTests = [\n      {\n        name: 'Busca Tipos Ativos',\n        query: () => supabase.from('member_types').select('*').eq('is_active', true)\n      },\n      {\n        name: 'Busca Planos Ativos',\n        query: () => supabase.from('subscription_plans').select('*').eq('is_active', true)\n      },\n      {\n        name: 'Contagem de Registros',\n        query: () => supabase.from('member_types').select('id', { count: 'exact' })\n      }\n    ];\n\n    for (const test of performanceTests) {\n      try {\n        const start = Date.now();\n        const { data, error } = await test.query();\n        const duration = Date.now() - start;\n\n        if (error) {\n          result.checks.push({\n            name: test.name,\n            status: 'fail',\n            message: `Erro na query: ${error.message}`,\n            details: { error, duration }\n          });\n          log.error(`${test.name}: ${error.message}`);\n        } else if (duration > 2000) {\n          result.checks.push({\n            name: test.name,\n            status: 'warning',\n            message: `Performance ruim: ${duration}ms`,\n            details: { duration, recordCount: data?.length }\n          });\n          log.warning(`${test.name}: Lento (${duration}ms)`);\n        } else if (duration > 500) {\n          result.checks.push({\n            name: test.name,\n            status: 'warning',\n            message: `Performance aceit√°vel: ${duration}ms`,\n            details: { duration, recordCount: data?.length }\n          });\n          log.warning(`${test.name}: Aceit√°vel (${duration}ms)`);\n        } else {\n          result.checks.push({\n            name: test.name,\n            status: 'pass',\n            message: `Performance boa: ${duration}ms`,\n            details: { duration, recordCount: data?.length }\n          });\n          log.success(`${test.name}: R√°pido (${duration}ms)`);\n        }\n      } catch (error) {\n        result.checks.push({\n          name: test.name,\n          status: 'fail',\n          message: `Erro inesperado: ${error}`,\n          details: error\n        });\n        log.error(`Erro ${test.name}: ${error}`);\n      }\n    }\n\n    this.results.push(result);\n  }\n\n  private generateReport(): void {\n    log.title('Relat√≥rio Final de Sa√∫de do Sistema');\n\n    let totalChecks = 0;\n    let passedChecks = 0;\n    let warningChecks = 0;\n    let failedChecks = 0;\n\n    console.log('\\n' + '='.repeat(80));\n    console.log(`${colors.bold}RELAT√ìRIO DE SA√öDE DO SISTEMA COMADEMIG${colors.reset}`);\n    console.log('='.repeat(80));\n\n    this.results.forEach(category => {\n      console.log(`\\n${colors.bold}${category.category}:${colors.reset}`);\n      console.log('-'.repeat(40));\n\n      category.checks.forEach(check => {\n        totalChecks++;\n        \n        const statusIcon = {\n          pass: '‚úÖ',\n          warning: '‚ö†Ô∏è',\n          fail: '‚ùå'\n        }[check.status];\n\n        const statusColor = {\n          pass: colors.green,\n          warning: colors.yellow,\n          fail: colors.red\n        }[check.status];\n\n        console.log(`  ${statusIcon} ${statusColor}${check.name}${colors.reset}: ${check.message}`);\n\n        if (check.status === 'pass') passedChecks++;\n        else if (check.status === 'warning') warningChecks++;\n        else failedChecks++;\n      });\n    });\n\n    console.log('\\n' + '='.repeat(80));\n    console.log(`${colors.bold}RESUMO:${colors.reset}`);\n    console.log(`Total de verifica√ß√µes: ${totalChecks}`);\n    console.log(`${colors.green}‚úÖ Passou: ${passedChecks}${colors.reset}`);\n    console.log(`${colors.yellow}‚ö†Ô∏è  Avisos: ${warningChecks}${colors.reset}`);\n    console.log(`${colors.red}‚ùå Falhou: ${failedChecks}${colors.reset}`);\n\n    const successRate = ((passedChecks / totalChecks) * 100).toFixed(1);\n    console.log(`\\n${colors.bold}Taxa de Sucesso: ${successRate}%${colors.reset}`);\n\n    if (failedChecks === 0 && warningChecks === 0) {\n      console.log(`\\n${colors.green}${colors.bold}üéâ SISTEMA SAUD√ÅVEL - Todos os testes passaram!${colors.reset}`);\n    } else if (failedChecks === 0) {\n      console.log(`\\n${colors.yellow}${colors.bold}‚ö†Ô∏è  SISTEMA FUNCIONAL - Alguns avisos encontrados${colors.reset}`);\n    } else {\n      console.log(`\\n${colors.red}${colors.bold}üö® PROBLEMAS DETECTADOS - A√ß√£o necess√°ria${colors.reset}`);\n    }\n\n    console.log('\\n' + '='.repeat(80));\n\n    // Salvar relat√≥rio em arquivo JSON\n    const reportData = {\n      timestamp: new Date().toISOString(),\n      summary: {\n        total: totalChecks,\n        passed: passedChecks,\n        warnings: warningChecks,\n        failed: failedChecks,\n        successRate: parseFloat(successRate)\n      },\n      results: this.results\n    };\n\n    // Em um ambiente real, salvaria em arquivo\n    // require('fs').writeFileSync('health-check-report.json', JSON.stringify(reportData, null, 2));\n    \n    log.info('Relat√≥rio completo dispon√≠vel no objeto results');\n  }\n}\n\n// Executar verifica√ß√£o se chamado diretamente\nif (require.main === module) {\n  const checker = new SystemHealthChecker();\n  checker.runAllChecks().catch(error => {\n    console.error('Erro fatal na verifica√ß√£o:', error);\n    process.exit(1);\n  });\n}\n\nexport { SystemHealthChecker };"